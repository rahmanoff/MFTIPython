# Алгоритмы на Python 3. Лекция №5
# Практика: http://judge.mipt.ru/mipt_cs_on_python3/
# Видео - https://www.youtube.com/watch?v=3I6OjxoeSS8
# Практика - https://github.com/mipt-cs/course-site-python3/wiki

# курс: Информатика. Алгоритмы и структуры данных на Python 3.
# лектор: Хирьянов Тимофей Фёдорович
# 03.10.2017

# Темы, рассмотренные на лекции №5:
# - Список как массив данных.
# - Линейный поиск в массиве.
# - Копирование массива. Копирование задом-наперёд.
# - Алгоритм обращения массива.
# - Алгоритм циклического сдвига в массиве.
# - Добавление элемента в конец и в начало массива.
# - Удаление элемента из конца и начала массива.
# - Ссылочная модель данных в Python. Изменяемость списка.
# - Решето Эратосфена.

# Массивы - тип list
# Вывод элементов массива
A = [1,2,3,4,5]
print("A:",A)
i=0
for x in A:
    print("A[",i,"]:",x,type(x))
    i+=1

# Изменяемые и не изменяемые типы данных Python
# Ссылочная можель данных. Есть имена и есть объекты.
# Доступ к элементу массива по индексу - "k"
# Изменение элементов массива
for k in range (5):
    A[k] = A[k] * A[k]
    print(A[k])

# Создание массива
A = [0]*1000

# Индикатор заполненности
top = 0

# Ввод чисел в массив
x = int(input())
while x != 0:
    A[top] = x
    top +=1
    x = int(input())

# Вывод данных массива в обратной последовательности, не изменяя данных в массиве
for k in range (top-1, -1, -1):
    print(A[k])

# Копирование массива
# Размер массива - N
N = int(input())
A = [0]*N
B = [0]*N

# Ввод данных в массив с клавиатуры
for k in range (N):
    A[k] = int(input())

# Копирование данных из массива А в массив В
for k in range (N):
    B[k] = A[k]

# Создание массива С - копии массива А
C = list(A)

# Линейный поиск в массиве
def array_search(A:list, N:int, x:int):
    """ Осуществляет поиск числа x в массиве А, от 0 до N-1 индекса включительно. Возвращет индекс элемента x в массиве А. 
    Или -1, если такого элемента в массиве нет. 
    Если в массиве несколько одинаковых элементов, равных х, то вернуть индекс первого по счету."""

    for k in range(N):
        if A[k] == x:
            return k
    return -1

# Тестирование работы функции линейного поиска в массиве
def test_array_search():
    # Тест 1
    A1 = [1,2,3,4,5]
    m = array_search(A1, 5, 8)
    if m == -1:
        print("Test1 - Ok!")
    else:
        print("Test1 - Fail!")
    # Тест 2
    A2 = [-1,-2,-3,-4,-5]
    m = array_search(A2, 5, -3)
    if m == 2:
        print("Test2 - Ok!")
    else:
        print("Test2 - Fail!")
    # Тест 3
    A3 = [10,20,30,10,10]
    m = array_search(A3, 5, 10)
    if m == 0:
        print("Test3 - Ok!")
    else:
        print("Test3 - Fail!")
# Запуск функции тестирования
test_array_search()

# Алгоритм обращения массива
def invert_array(A:list, N:int):
    """ Обращение (поворот задом-наперед) массива А, размером N, в рамках индексов от 0 до N-1 """
    for k in range (N//2):
        A[k],A[N-1-k] = A[N-1-k],A[k] # Обмен двух переменных значениями

# Тестирование работы функции обращения массива
def test_invert_array():
    # Тест 1
    A1 = [1,2,3,4,5]
    print(A1)
    invert_array(A1,5)
    print(A1)
    if A1 == [5,4,3,2,1]:
        print("Test1 - Ok!")
    else:
        print("Test1 - Fail!")
    # Тест 2
    A2 = [0,0,0,0,0,0,0,10]
    print(A2)
    invert_array(A2,8)
    print(A2)
    if A2 == [10,0,0,0,0,0,0,0]:
        print("Test2 - Ok!")
    else:
        print("Test2 - Fail!")
# Запуск функции тестированния
test_invert_array()

# Циклический сдвиг в массиве через временную переменную - tmp
# Есть массив А из N элементов
# Сдвиг массива Влево
tmp = A[0]
for k in range(N-1):
    A[k] = A[k+1]
A[N-1] = tmp
# Сдвиг массива Вправо
tmp = A[N-1]
for k in range (N-2, -1,-1):
    A[k+1] = A[k]
A[0] = tmp

# Решето Эратосфена
A = [True]*N
A[0]=A[1]=False
for k in range (2,N):
    if A[k]:
        for m in range(2*k,N,k):
            A[m] = False
print("Решето Эратосфена",A)
for k in range (N):
    print(k,'-', 'простое' if A[k] else 'составное') # <- Тернарный оператор
